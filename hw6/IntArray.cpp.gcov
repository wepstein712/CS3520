        -:    0:Source:IntArray.cpp
        -:    0:Graph:IntArray.gcno
        -:    0:Data:IntArray.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "IntArray.hpp"
        -:    2:#include <cstring>
        -:    3:#include <stdexcept>
        -:    4:#include <utility>
        -:    5:
        4:    6:IntArray::IntArray():
        4:    7:  IntArray(0)
        -:    8:{
        4:    9:}
        -:   10:
       26:   11:IntArray::IntArray(size_t sz):
       26:   12:  m_arr(new int[sz]),
       26:   13:  m_sz(sz)
        -:   14:{
       26:   15:  memset(m_arr, 0, sizeof(int) * m_sz);
       26:   16:}
        -:   17:
       78:   18:IntArray::IntArray(const std::initializer_list<int> & lst):
       78:   19:  m_arr(new int[lst.size()]),
       78:   20:  m_sz(lst.size())
        -:   21:{
       78:   22:  size_t ii = 0;
      445:   23:  for (int elem: lst) {
      367:   24:    m_arr[ii] = elem;
      367:   25:    ++ ii;
        -:   26:  }
       78:   27:}
        -:   28:
       19:   29:IntArray::IntArray(const IntArray & o):
       19:   30:  m_arr(new int[o.m_sz]),
       19:   31:  m_sz(o.m_sz)
        -:   32:{
       19:   33:  memcpy(m_arr, o.m_arr, sizeof(int) * m_sz);
       19:   34:}
        -:   35:
    #####:   36:IntArray::IntArray(IntArray && o):
        -:   37:  m_arr(o.m_arr),
    #####:   38:  m_sz(o.m_sz)
        -:   39:{
    #####:   40:  o.m_arr = nullptr;
    #####:   41:  o.m_sz = 0;
    #####:   42:}
        -:   43:
       38:   44:IntArray::~IntArray() {
       38:   45:  delete [] m_arr;
       38:   46:}
        -:   47:
        6:   48:const int *IntArray::ptr() const {
        6:   49:  return m_arr;
        -:   50:}
        -:   51:
       17:   52:size_t IntArray::size() const {
       17:   53:  return m_sz;
        -:   54:}
        -:   55:
        7:   56:IntArray & IntArray::operator=(const IntArray & o) {
        7:   57:  if (this != &o) {
        7:   58:    if (m_sz != o.m_sz) {
        5:   59:      delete [] m_arr;
        5:   60:      m_arr = new int[o.m_sz];
        5:   61:      m_sz = o.m_sz;
        -:   62:    }
        7:   63:    memcpy(m_arr, o.m_arr, sizeof(int) * m_sz);
        -:   64:  }
        7:   65:  return *this;
        -:   66:}
        -:   67:
        4:   68:IntArray & IntArray::operator=(IntArray && o) {
        4:   69:  if (this != &o) {
        4:   70:    delete [] m_arr;
        4:   71:    m_arr = o.m_arr;
        4:   72:    m_sz = o.m_sz;
        4:   73:    o.m_arr = nullptr;
        4:   74:    o.m_sz = 0;
        -:   75:  }
        4:   76:  return *this;
        -:   77:}
        -:   78:
       16:   79:int & IntArray::operator[](size_t ind) {
       16:   80:  if (ind >= m_sz) {
        1:   81:    throw std::out_of_range("out of range");
        -:   82:  }
       15:   83:  return m_arr[ind];
        -:   84:}
        -:   85:
       16:   86:const int & IntArray::operator[](size_t ind) const {
       16:   87:  if (ind >= m_sz) {
        1:   88:    throw std::out_of_range("out of range");
        -:   89:  }
       15:   90:  return m_arr[ind];
        -:   91:}
        -:   92:
        8:   93:bool operator==(const IntArray & lhs, const IntArray & rhs) {
        8:   94:  if (lhs.m_sz != rhs.m_sz) {
        2:   95:    return false;
        -:   96:  }
        -:   97:
       12:   98:  for (size_t ii = 0; ii < lhs.m_sz; ++ ii) {
        7:   99:    if (lhs.m_arr[ii] != rhs.m_arr[ii]) {
        1:  100:      return false;
        -:  101:    }
        -:  102:  }
        -:  103:
        5:  104:  return true;
        -:  105:}
        -:  106:
        1:  107:bool operator!=(const IntArray & lhs, const IntArray & rhs) {
        1:  108:  return !(lhs == rhs);
        -:  109:}
